diff --git a/build.xml b/build.xml
index 864bf7d0e..b306da040 100755
--- a/build.xml
+++ b/build.xml
@@ -135,6 +135,7 @@
   </target>
 
   <target name="check-target-properties">
+    <echo message="target.file ${target.file}" />   
     <available property="target_config_present" file="${target.file}"/>
     <fail unless="target_config_present">
       Target file ${target.file} not present. Please set target.name to the name of file in
@@ -2124,6 +2125,8 @@ const char *rvm_target_configuration = "${target.file}";
         <include name="*.h"/>
       </fileset>
     </copy>
+    <echo message="Dir.base ${dist.base}" />
+    <echo message="Target Architecture is : ${target.arch}" />
     <echo file="${dist.base}/constants.properties"><![CDATA[# Build time constants used when building image.
 config.name=${config.name}
 config.runtime.compiler=${config.runtime.compiler}
diff --git a/kenan/IterationCallBack.java b/kenan/IterationCallBack.java
index 6bd19801f..a1696c338 100755
--- a/kenan/IterationCallBack.java
+++ b/kenan/IterationCallBack.java
@@ -40,8 +40,17 @@ public void start(String benchmark) {
 
 }
 
+public static long jvm_start = 0;
 public IterationCallBack(CommandLineArgs args) {
-	super(args);
+		super(args);
+		try {
+			Class cls = Class.forName("org.jikesrvm.VM");
+			Method m = cls.getDeclaredMethod("get_startup_ts", null);
+			Object o =  m.invoke(null, null);
+			jvm_start = (Long) o;
+		} catch(Exception exc) {
+			 exc.printStackTrace();
+		}
 }
 
 public void complete(String benchmark, boolean valid) {
@@ -50,7 +59,7 @@ public void complete(String benchmark, boolean valid) {
 		FileWriter fileWriter = new FileWriter("iteration_times");
 		PrintWriter printWriter = new PrintWriter(fileWriter);
 		for(int i=1; i<= CURRENT_ITERATION;i++) {
-			printWriter.printf("%d,%d \n",START_ITER_TS[i-1],STOP_ITER_TS[i-1]);
+			printWriter.printf("%d,%d \n",START_ITER_TS[i-1] -jvm_start,STOP_ITER_TS[i-1] - jvm_start);
 		}
 		printWriter.close();
 		
diff --git a/rapl.sh b/rapl.sh
index 916a60e29..f394ccbd1 100755
--- a/rapl.sh
+++ b/rapl.sh
@@ -1,5 +1,7 @@
 #!/bin/bash
 DEBUG=false
+dacapoJar="dacapo-2006-10-MR2.jar"
+#dacapoJar="dacapo-9.12-bach.jar"
 freqOpt=8
 freq=('0' '2201000' '2200000' '2100000' '2000000' '1900000' '1800000' '1700000' '1600000' '1500000' '1400000' '1300000' '1200000')
 #freq=('0' '2601000' '2400000' '2200000' '2000000' '1800000' '1600000' '1400000' '1200000' '2600000');
@@ -33,9 +35,15 @@ runJikesNoEnergyProfile() {
 
 }
 runJikesProfile() {
-		sudo dist/FullAdaptiveMarkSweep_x86_64-linux/rvm  "-Xmx4000M" "-X:gc:eagerMmapSpaces=true"  "-X:vm:errorsFatal=true" "-X:gc:printPhaseStats=true" "-X:vm:interruptQuantum=${4}" "-X:aos:enable_recompilation=true" "-X:aos:hot_method_time_min=0.1" "-X:aos:hot_method_time_max=1" "-X:aos:frequency_to_be_printed=${2}" "-X:aos:event_counter=${3}" "-X:aos:enable_counter_profiling=false" "-X:aos:enable_energy_profiling=true" "-X:aos:profiler_file=doubleSampleWindow_1ms.csv" "-X:aos:enable_scaling_by_counters=false" "-X:aos:enable_counter_printer=true" "-cp" "dacapo-9.12-bach.jar:." "Harness" "-s" "large" "sunflow" "-n" "10" "--callback" "kenan.IterationCallBack" &> freq_${kkfreq}
+		sudo dist/FullAdaptiveMarkSweep_x86_64-linux/rvm  "-Xmx4000M" "-X:gc:eagerMmapSpaces=true"  "-X:vm:errorsFatal=true" "-X:gc:printPhaseStats=true" "-X:vm:interruptQuantum=${4}" "-X:aos:enable_recompilation=true" "-X:aos:hot_method_time_min=0.1" "-X:aos:hot_method_time_max=1" "-X:aos:frequency_to_be_printed=${2}" "-X:aos:event_counter=${3}" "-X:aos:enable_counter_profiling=false" "-X:aos:enable_energy_profiling=true" "-X:aos:profiler_file=doubleSampleWindow_1ms.csv" "-X:aos:enable_scaling_by_counters=false" "-X:aos:enable_counter_printer=true" "-cp" "$dacapoJar:." "Harness" "-s" "large" "sunflow" "--iterations" "10" "--callback" "kenan.IterationCallBack" &> freq_${kkfreq}
 }
 
+
+runJikesProfileKenan() {
+		sudo dist/FullAdaptiveMarkSweep_x86_64-linux/rvm  "-Xmx4000M" "-X:gc:eagerMmapSpaces=true"  "-X:vm:errorsFatal=true" "-X:gc:printPhaseStats=true" "-X:vm:interruptQuantum=${4}" "-X:aos:enable_recompilation=true" "-X:aos:hot_method_time_min=0.1" "-X:aos:hot_method_time_max=1" "-X:aos:frequency_to_be_printed=${2}" "-X:aos:event_counter=${3}" "-X:aos:enable_counter_profiling=false" "-X:aos:enable_energy_profiling=true" "-X:aos:profiler_file=doubleSampleWindow_1ms.csv" "-X:aos:enable_scaling_by_counters=false" "-X:aos:enable_counter_printer=true" "-cp" "$dacapoJar:." -jar $dacapoJar  "-s" "large" "sunflow" "--iterations" "10" "--callback" "kenan.IterationCallBack" &> freq_${kkfreq}
+}
+
+
 runJikesNoEnergyProfileGraphchi() {
 		sudo dist/FullAdaptiveMarkSweep_x86_64-linux/rvm  "-Xmx2500M" "-X:vm:errorsFatal=true" "-X:aos:enable_recompilation=true" "-X:aos:hot_method_time_min=${hotMin[${1}]}" "-X:aos:hot_method_time_max=${hotMax[${1}]}" "-X:aos:frequency_to_be_printed=${2}" "-X:aos:event_counter=${3}" "-X:aos:enable_counter_profiling=true" "-X:aos:enable_energy_profiling=false" "-X:aos:profiler_file=${4}_${6}threads.csv" "-X:aos:enable_scaling_by_counters=false" "-X:aos:enable_counter_printer=true" "-cp" "graphchi-java-0.2.2.jar" "edu.cmu.graphchi.apps.Pagerank" "facebook/414.edges" "20" "edgelist"
 
@@ -58,14 +66,15 @@ fi
 
 timeSlice=$((${timeSlice}))		
 #
-#for((i=1;i<=12;i++))
-#do
-       i=1
+for((i=1;i<=12;i++))
+do
+       #i=1
        kkfreq="$i"
        sudo java energy.Scaler $i userspace
+       #Hi Kenan, I also tried 4 instead of 8 below runJikesProfile 8
        runJikesProfile 4 ${freq[$i]} ${events[0]},${events[1]} ${timeSlice[2]} Energy -t 8 
        sudo mv kenan.csv counter_based_sampling_kenan.${i}.csv
        sudo mv iteration_times counter_based_sampling_iteration_times_$i
-#done
+done
 ##	
 sleep 10 
diff --git a/rvm/src/org/jikesrvm/VM.java b/rvm/src/org/jikesrvm/VM.java
index e3f036914..8c636a209 100755
--- a/rvm/src/org/jikesrvm/VM.java
+++ b/rvm/src/org/jikesrvm/VM.java
@@ -86,8 +86,13 @@ public class VM extends Properties {
   public static void print_hello() {
       sysWriteln("Hello from JikesRVM");		
   }
-	
-	
+
+
+    
+  public static long get_startup_ts() {
+  	return Service.start_ts;	  
+  }
+    
   /**
    * For assertion checking things that should never happen.
    */
@@ -480,7 +485,7 @@ public class VM extends Properties {
 
     //TODO::Kenan::Khaled::LogQueue::log_queue
     //Link Create a System Call for LogQueue
-    sysCall.init_log_queue(500,5);
+    sysCall.init_log_queue(500,Scaler.getPerfEnerCounterNum());
 
     if (VM.BuildForAdaptiveSystem) {
       if (verboseBoot >= 1) VM.sysWriteln("Initializing adaptive system");
diff --git a/rvm/src/org/jikesrvm/energy/Service.java b/rvm/src/org/jikesrvm/energy/Service.java
index 97dc5ba39..927e911ca 100755
--- a/rvm/src/org/jikesrvm/energy/Service.java
+++ b/rvm/src/org/jikesrvm/energy/Service.java
@@ -24,6 +24,10 @@ public class Service implements ProfilingTypes {
 	public static double[][] prevProfile = new double[INIT_SIZE*2][3];
 	public static boolean[] prevProfileInit = new boolean[INIT_SIZE*2];
 	public static boolean profileEnable = false;
+
+	public static long start_ts = System.currentTimeMillis();
+
+	
 		
 		/**Index is composed by hashcode of "method ID#thread ID" in order to differentiate method invocations by different threads*/
 		public static char [] info = {'i','o', '\n'};
@@ -137,7 +141,8 @@ public class Service implements ProfilingTypes {
 				//Do profile	
 				getProfileAttrs(profileAttrs);
 				int freq = (int) Controller.options.FREQUENCY_TO_BE_PRINTED;
-				SysCall.sysCall.add_log_entry(profileAttrs,cmid,System.currentTimeMillis(),freq);
+				int cts = (int) (System.currentTimeMillis() -  start_ts);
+				SysCall.sysCall.add_log_entry(profileAttrs,cmid,cts);
 				
 				thread.skippedInvocations = RVMThread.STRIDE;
 				thread.samplesThisTimerInterrupt--;
diff --git a/rvm/src/org/jikesrvm/runtime/SysCall.java b/rvm/src/org/jikesrvm/runtime/SysCall.java
index b73701707..6247b7ec3 100755
--- a/rvm/src/org/jikesrvm/runtime/SysCall.java
+++ b/rvm/src/org/jikesrvm/runtime/SysCall.java
@@ -537,7 +537,7 @@ public abstract class SysCall {
 	   public abstract void print_logs();
 
 	   @SysCallTemplate
-	   public abstract void add_log_entry(double[] attrs,int cmdid,long timestamp,int freq);
+	   public abstract void add_log_entry(double[] attrs,int cmdid,int timestamp);
 	   @SysCallTemplate
 	   public abstract int add_method_entry(byte[] m, byte[] c);
 	   
diff --git a/tools/bootloader/log_queue.c b/tools/bootloader/log_queue.c
index 136da75b1..6a40b0d1c 100755
--- a/tools/bootloader/log_queue.c
+++ b/tools/bootloader/log_queue.c
@@ -22,6 +22,7 @@ typedef struct method_entry {
 struct method_entry *current_method_entry;
 struct method_entry *head_method_entry;
 int method_counter =0;
+int iteration_no=1;
 int allocation_indx = 0;
 FILE *log_file;
 method_entry* allocate_method_entry() {
@@ -91,7 +92,7 @@ int add_method_entry(char* method_name, char* cls) {
 	typedef struct thread_stats {
 	    int* timestamps;
 	    int* cmdids;
-	    float *profile_attrs;
+	    double *profile_attrs;
 	    int log_num;
 	    struct thread_stats *next;
 	    int tid;
@@ -108,7 +109,7 @@ int add_method_entry(char* method_name, char* cls) {
 	    check_malloc(lstats->timestamps, "Allocating Timestamps");
 	    lstats->cmdids=malloc(sizeof(int)*METHOD_ENTRY_PREALLOC);
 	    check_malloc(lstats->cmdids,"Allocating CMDIDS");
-	    lstats->profile_attrs=malloc(sizeof(float)*METHOD_ENTRY_PREALLOC*num_profile_attrs);
+	    lstats->profile_attrs=malloc(sizeof(double)*METHOD_ENTRY_PREALLOC*num_profile_attrs);
 	    check_malloc(lstats->profile_attrs,"Allocating Profile Attributes");
 	    //lstats->frequencies=malloc(sizeof(long)*METHOD_ENTRY_PREALLOC);
 	    //check_malloc(lstats->frequencies,"Allocating frequencies");
@@ -131,7 +132,7 @@ int add_method_entry(char* method_name, char* cls) {
 	    number_of_threads++;
 	}
 
-	void assign_log_entry(double* attrs, int cmdid,long long timestamp,int freq) {
+	void assign_log_entry(double* attrs, int cmdid,int ts) {
 	    //printf("[assign_log_entry] Assigning \n ");
     	    //struct timespec spec;
 	    //clock_gettime(CLOCK_MONOTONIC,&spec);
@@ -147,10 +148,10 @@ int add_method_entry(char* method_name, char* cls) {
 	    	printf("Never ever done that \n");
 	    }*/
 	    
-	    current->timestamps[current->log_num]=0;
+	    current->timestamps[current->log_num]=ts;
 	    
 	    //printf("Step 1 \n");
-	    current->cmdids[current->log_num]=0;
+	    current->cmdids[current->log_num]=cmdid;
 	    //current->frequencies[current->log_num]=freq;
 	    int profile_start_indx = current->log_num*num_profile_attrs;
 	    //printf("Step 2 \n");
@@ -168,8 +169,7 @@ int add_method_entry(char* method_name, char* cls) {
 
 
 	//This method needs to be called from Jikes
-	extern void add_log_entry(double* attrs,  int cmdid,long long timestamp,int freq) {
-	    
+	extern void add_log_entry(double* attrs,  int cmdid,int timestamp) {	  
 	    //printf("[add_log_entry] .... \n");
 	    //printf("Current Log Num %d \n",current->log_num);
 	    
@@ -179,7 +179,7 @@ int add_method_entry(char* method_name, char* cls) {
 	    }
 	   
 	    //printf("add_log_entry: alocated"); 
-	    assign_log_entry(attrs,cmdid,timestamp,freq);
+	    assign_log_entry(attrs,cmdid,timestamp);
 	    //printf("add_log_entry: assigned");
 }
 
@@ -195,7 +195,8 @@ extern void print_logs() {
 	    //printf("[print_logs] Print number of logs %d \n",thread_stat->log_num);
             for(log_indx=0;log_indx < thread_stat->log_num;log_indx++) {
                 //fprintf(log_file,"%d,",thread_stat->frequencies[log_indx]);
-		fprintf(log_file,"%d,",thread_stat->timestamps[log_indx]);
+		fprintf(log_file,"%d,",iteration_no);
+		fprintf(log_file,",%d,",thread_stat->timestamps[log_indx]);
                 print_method_name(thread_stat->cmdids[log_indx]);
 		fprintf(log_file,"%d,",thread_stat->tid);
                 fprintf(log_file,"%d,", thread_stat->cmdids[log_indx]);
@@ -233,6 +234,7 @@ extern void init_log_queue(int p_pre_allocation, int profile_attrs) {
 //Mark all allocated data in previous iterations as usable
 extern void end_iteration() {
 	    print_logs();
+	    iteration_no++;
 	    //Free allocated resources in previous iteration
 	    for(int thread_idx=0;thread_idx<number_of_threads;thread_idx++) {
         	thread_stats *head = thread_stats_g[thread_idx];
diff --git a/tools/bootloader/sys.h b/tools/bootloader/sys.h
index f5a7fa971..a16654420 100755
--- a/tools/bootloader/sys.h
+++ b/tools/bootloader/sys.h
@@ -151,7 +151,7 @@ EXTERNAL int ProfileInit();
 EXTERNAL void register_thread_stat();
 EXTERNAL void init_log_queue(int,int);
 EXTERNAL void print_logs();
-EXTERNAL void add_log_entry(double*,int,long long,int);
+EXTERNAL void add_log_entry(double*,int,int);
 EXTERNAL int add_method_entry(char*,char*);
 EXTERNAL void end_iteration();
 
diff --git a/tools/bootloader/sysMisc.c b/tools/bootloader/sysMisc.c
index 4cc38693e..cbc9a85b4 100755
--- a/tools/bootloader/sysMisc.c
+++ b/tools/bootloader/sysMisc.c
@@ -128,7 +128,7 @@ EXTERNAL jlong sysParseMemorySize(const char *sizeName, const char *sizeFlag,
                                   const char *subtoken /* e.g., "200M" or "200" */)
 {
   int fastExit = 0;
-  unsigned ret_uns;
+  Extent ret_uns;
   TRACE_PRINTF("%s: sysParseMemorySize %s\n", Me, token);
   ret_uns = parse_memory_size(sizeName, sizeFlag, defaultFactor,
                                        (Extent) roundTo, token, subtoken,
@@ -220,7 +220,7 @@ EXTERNAL Extent parse_memory_size(const char *sizeName, /*  "initial heap" or "m
   }
 
   if (!*fastExit) {
-    if ( errno == ERANGE || userNum > (((long double) (UINT_MAX - roundTo))/factor) )
+    if ( errno == ERANGE || userNum > (((long double) (ULONG_MAX - roundTo))/factor) )
     {
       CONSOLE_PRINTF( "%s: \"%s\": out of range to represent internally\n", Me, subtoken);
       *fastExit = 1;
@@ -245,7 +245,7 @@ EXTERNAL Extent parse_memory_size(const char *sizeName, /*  "initial heap" or "m
     return 0U;              // Distinguished value meaning trouble.
   }
   tot_d = userNum * factor;
-  if (tot_d > (UINT_MAX - roundTo) || tot_d < 1) {
+  if (tot_d > (ULONG_MAX - roundTo) || tot_d < 1) {
     ERROR_PRINTF("Unexpected memory size %Lf\n", tot_d);
     exit(EXIT_STATUS_BOGUS_COMMAND_LINE_ARG);
   }
