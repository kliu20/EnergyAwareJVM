diff --git a/changes b/changes
index 1291d9539..e69de29bb 100644
--- a/changes
+++ b/changes
@@ -1,917 +0,0 @@
-diff --git a/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Statistics.java b/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Statistics.java
-index 1ebaeb482..7ce1fee6b 100644
---- a/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Statistics.java
-+++ b/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Statistics.java
-@@ -12,7 +12,9 @@
-  */
- package org.jikesrvm.mm.mmtk;
- 
-+import org.mmtk.utility.Constants;
- import org.mmtk.utility.statistics.PerfEvent;
-+import org.jikesrvm.VM;
- import org.jikesrvm.runtime.Time;
- import static org.jikesrvm.runtime.SysCall.sysCall;
- 
-@@ -42,12 +44,12 @@ public final class Statistics extends org.mmtk.vm.Statistics {
- 
-   @Override
-   public double nanosToMillis(long c) {
--    return (c) / 1e6;
-+    return (c)/1e6;
-   }
- 
-   @Override
-   public double nanosToSecs(long c) {
--    return (c) / 1e9;
-+    return (c)/1e9;
-   }
- 
-   @Override
-@@ -62,6 +64,14 @@ public final class Statistics extends org.mmtk.vm.Statistics {
- 
-   private PerfEvent[] perfEvents;
- 
-+	/**
-+	* @author kenan
-+	*/
-+//	@Override
-+//	public PerfEvent[] getPerfEvents() {
-+//		  return perfEvents;
-+//	}
-+
-   @Override
-   @Interruptible
-   public void perfEventInit(String events) {
-diff --git a/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Strings.java b/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Strings.java
-index d1494b6eb..fc62c4ac4 100644
---- a/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Strings.java
-+++ b/MMTk/ext/vm/jikesrvm/org/jikesrvm/mm/mmtk/Strings.java
-@@ -12,7 +12,9 @@
-  */
- package org.jikesrvm.mm.mmtk;
- 
-+import org.jikesrvm.util.Services;
- import org.jikesrvm.VM;
-+import org.jikesrvm.classloader.RVMMethod;
- import org.jikesrvm.scheduler.RVMThread;
- import org.jikesrvm.util.Services;
- import org.vmmagic.pragma.*;
-@@ -30,6 +32,7 @@ public final class Strings extends org.mmtk.vm.Strings {
-     VM.tsysWrite(c, len);
-   }
- 
-+
-   @Override
-   public int copyStringToChars(String str, char [] dst,
-                                int dstBegin, int dstEnd) {
-@@ -57,6 +60,10 @@ public final class Strings extends org.mmtk.vm.Strings {
-                                     int dstBegin, int dstEnd) {
-     if (VM.VerifyAssertions) VM._assert(VM.runningVM);
-     // FIXME Why do we need to disable thread switching here, in uninterruptible code??
-+    //Kenan
-+//    RVMMethod method = VM.preYPDisabled();
-+//    VM.sysWriteln("Before YP is disabled by safeCopyStringToChars, the method is: " + method);
-+
-     RVMThread.getCurrentThread().disableYieldpoints();
-     char[] str_backing = java.lang.JikesRVMSupport.getBackingCharArray(str);
-     int str_length = java.lang.JikesRVMSupport.getStringLength(str);
-@@ -66,6 +73,8 @@ public final class Strings extends org.mmtk.vm.Strings {
-       Services.setArrayNoBarrier(dst, dstBegin + i, str_backing[str_offset + i]);
-     }
-     RVMThread.getCurrentThread().enableYieldpoints();
-+//    method = VM.postYPEnabled();
-+//    VM.sysWriteln("After YP is disabled by safeCopyStringToChars, the method is: " + method);
-     return n;
-   }
-   /**
-diff --git a/MMTk/src/org/mmtk/utility/statistics/PerfEvent.java b/MMTk/src/org/mmtk/utility/statistics/PerfEvent.java
-index ba0a9161b..8f8a4160a 100644
---- a/MMTk/src/org/mmtk/utility/statistics/PerfEvent.java
-+++ b/MMTk/src/org/mmtk/utility/statistics/PerfEvent.java
-@@ -51,11 +51,27 @@ public final class PerfEvent extends LongCounter {
-   }
- 
-   /**
-+   * @author kenan
-+   * Work around: wrapper to get readBuffer[RAW_COUNT] in getCurrentValue() out side of this
-+   * package.
-+   */
-+//  public long getEventCounter() {
-+//	  return readBuffer[RAW_COUNT];
-+//  }
-+
-+  //kmahmou1:: Whare is the variable total count declared ?????
-+  public long getAccumulatedCount() {
-+	  return totalCount;
-+  }
-+
-+  /**
-    * Counters are 64 bit unsigned in the kernel but only 63 bits are available in Java
-    */
-   @Override
-   protected long getCurrentValue() {
-+	  //Kenan
-     VM.statistics.perfEventRead(index, readBuffer);
-+//    VM.statistics.perfEventRead(readBuffer);
-     if (readBuffer[RAW_COUNT] < 0 || readBuffer[TIME_ENABLED] < 0 || readBuffer[TIME_RUNNING] < 0) {
-       // Negative implies they have exceeded 63 bits.
-       overflowed = true;
-diff --git a/MMTk/src/org/mmtk/utility/statistics/Timer.java b/MMTk/src/org/mmtk/utility/statistics/Timer.java
-index 9474eac92..70029c743 100644
---- a/MMTk/src/org/mmtk/utility/statistics/Timer.java
-+++ b/MMTk/src/org/mmtk/utility/statistics/Timer.java
-@@ -85,6 +85,13 @@ public class Timer extends LongCounter {
-   final void printTotalMicro() {
-     printMicro(totalCount);
-   }
-+  /**
-+   * @author kenan
-+   *
-+   */
-+  public long getAccumulatedCount() {
-+	  return totalCount;
-+  }
- 
-   /**
-    * Print the total in milliseconds
-diff --git a/MMTk/src/org/mmtk/vm/Statistics.java b/MMTk/src/org/mmtk/vm/Statistics.java
-index 624d91283..6e4c6c232 100644
---- a/MMTk/src/org/mmtk/vm/Statistics.java
-+++ b/MMTk/src/org/mmtk/vm/Statistics.java
-@@ -12,6 +12,7 @@
-  */
- package org.mmtk.vm;
- 
-+import org.mmtk.utility.statistics.PerfEvent;
- import org.vmmagic.pragma.Interruptible;
- import org.vmmagic.pragma.Uninterruptible;
- 
-@@ -82,4 +83,5 @@ public abstract class Statistics {
-    * read (3 64-bit values).
-    */
-   public abstract void perfEventRead(int counter, long[] values);
-+//  public abstract void perfEventRead(long[] values);
- }
-diff --git a/build.xml b/build.xml
-index 37f2daf03..d39f90494 100644
---- a/build.xml
-+++ b/build.xml
-@@ -1956,8 +1956,14 @@ const char *rvm_target_configuration = "${target.file}";
-     <CompileCtoObj cfile="${bl.dir}/sysVarArgs.c"
-                        objfile="${build.base}/${target.obj-prefix}sysVarArgs${target.obj-ext}"
-                        cargs="${rvm.c.args}"/>
--
--    <CreateLibrary outdir="${build.base}" dllname="jvm" srcdir="${bl.dir}">
-+    <CompileCtoObj cfile="${bl.dir}/kenan.c"
-+		                          objfile="${build.base}/${target.obj-prefix}kenan${target.obj-ext}"
-+		                          cargs="${rvm.c.args}"/>
-+    <CompileCtoObj cfile="${bl.dir}/msr.c" 	 objfile="${build.base}/${target.obj-prefix}msr${target.obj-ext}" 	cargs="${rvm.c.args}" />
-+    <CompileCtoObj cfile="${bl.dir}/dvfs.c" 	 objfile="${build.base}/${target.obj-prefix}dvfs${target.obj-ext}" 	cargs="${rvm.c.args}" />
-+
-+		  
-+     <CreateLibrary outdir="${build.base}" dllname="jvm" srcdir="${bl.dir}">
-       <ObjectFiles>
-         <arg value="${build.base}/${target.obj-prefix}jvm${target.obj-ext}"/>
-         <arg value="${build.base}/${target.obj-prefix}sysAlignmentCheck${target.obj-ext}"/>
-@@ -1975,7 +1981,10 @@ const char *rvm_target_configuration = "${target.file}";
-         <arg value="${build.base}/${target.obj-prefix}sysThread_${target.arch}${target.obj-ext}"/>
-         <arg value="${build.base}/${target.obj-prefix}sysTime${target.obj-ext}"/>
-         <arg value="${build.base}/${target.obj-prefix}sysVarArgs${target.obj-ext}"/>
--      </ObjectFiles>
-+	<arg value="${build.base}/${target.obj-prefix}kenan${target.obj-ext}"/>
-+	<arg value="${build.base}/${target.obj-prefix}msr${target.obj-ext}"/>
-+	<arg value="${build.base}/${target.obj-prefix}dvfs${target.obj-ext}"/>
-+	</ObjectFiles>
-     </CreateLibrary>
- 
-     <!-- create vmi shared library (if building for Harmony)-->
-@@ -2029,7 +2038,10 @@ const char *rvm_target_configuration = "${target.file}";
-         <arg value="${build.base}/${target.obj-prefix}sysThread_${target.arch}${target.obj-ext}"/>
-         <arg value="${build.base}/${target.obj-prefix}sysTime${target.obj-ext}"/>
-         <arg value="${build.base}/${target.obj-prefix}sysVarArgs${target.obj-ext}"/>
--      </ObjectFiles>
-+	<arg value="${build.base}/${target.obj-prefix}kenan${target.obj-ext}"/>
-+	<arg value="${build.base}/${target.obj-prefix}msr${target.obj-ext}"/>
-+	<arg value="${build.base}/${target.obj-prefix}dvfs${target.obj-ext}"/>
-+	</ObjectFiles>
-     </CreateDLL>
- 
-     <!-- create jvm_jni shared library -->
-@@ -2054,7 +2066,8 @@ const char *rvm_target_configuration = "${target.file}";
-         <arg value="${build.base}/${target.obj-prefix}main${target.obj-ext}"/>
-       </ObjectFiles>
-     </CreateEXE>
--    
-+
-+
-     <antcall target="build-debug-symbols"/>
-   </target>
- 
-diff --git a/rvm/src/org/jikesrvm/VM.java b/rvm/src/org/jikesrvm/VM.java
-index a37648aa5..a953930df 100644
---- a/rvm/src/org/jikesrvm/VM.java
-+++ b/rvm/src/org/jikesrvm/VM.java
-@@ -16,6 +16,7 @@ import static org.jikesrvm.runtime.ExitStatus.EXIT_STATUS_BOGUS_COMMAND_LINE_ARG
- import static org.jikesrvm.runtime.ExitStatus.EXIT_STATUS_RECURSIVELY_SHUTTING_DOWN;
- import static org.jikesrvm.runtime.ExitStatus.EXIT_STATUS_SYSFAIL;
- 
-+import org.jikesrvm.compilers.common.CompiledMethods;
- import org.jikesrvm.adaptive.controller.Controller;
- import org.jikesrvm.adaptive.util.CompilerAdvice;
- import org.jikesrvm.architecture.StackFrameLayout;
-@@ -32,6 +33,12 @@ import org.jikesrvm.classloader.TypeReference;
- import org.jikesrvm.compilers.baseline.BaselineCompiler;
- import org.jikesrvm.compilers.common.BootImageCompiler;
- import org.jikesrvm.compilers.common.RuntimeCompiler;
-+import org.jikesrvm.energy.DataPrinter;
-+import org.jikesrvm.energy.EnergyCheckUtils;
-+import org.jikesrvm.energy.ProfileMap;
-+import org.jikesrvm.energy.ProfileQueue;
-+import org.jikesrvm.energy.ProfileStack;
-+import org.jikesrvm.energy.Scaler;
- import org.jikesrvm.mm.mminterface.MemoryManager;
- import org.jikesrvm.runtime.BootRecord;
- import org.jikesrvm.runtime.Callbacks;
-@@ -65,6 +72,8 @@ import org.vmmagic.unboxed.Extent;
- import org.vmmagic.unboxed.ObjectReference;
- import org.vmmagic.unboxed.Offset;
- import org.vmmagic.unboxed.Word;
-+import org.jikesrvm.energy.LogQueue;
-+
- 
- /**
-  * A virtual machine.
-@@ -464,6 +473,17 @@ public class VM extends Properties {
- 
-     if (VM.BuildForAdaptiveSystem) {
-       if (verboseBoot >= 1) VM.sysWriteln("Initializing adaptive system");
-+      //Kenan: Initialize hardware counter/energy based profiling structures
-+//      if(Controller.options.EVENTCOUNTER != null && Controller.options.EVENTCOUNTER.length() > 0){
-+		Scaler.initScaler();
-+		EnergyCheckUtils.initJrapl();
-+		Scaler.openDVFSFiles();
-+//	    ProfileStack.InitStack(EnergyCheckUtils.socketNum);
-+		ProfileMap.initProfileMap();
-+	    ProfileQueue.initShortMethod();
-+	    DataPrinter.initPrintStream();
-+	    LogQueue.InitStack(EnergyCheckUtils.socketNum);
-+//      }
-       Controller.boot();
-     }
- 
-@@ -2641,6 +2661,49 @@ public class VM extends Properties {
-   }
- 
-   /**
-+   * record method id and decrease its yield point enable count by 1 before the stack is operated
-+   * @author kenan
-+   * @return Compiled method name before yield point is disabled
-+   */
-+  public static RVMMethod preYPDisabled() {
-+		//Kenan:
-+		int disabledCMID = Magic.getCompiledMethodID(Magic.getCallerFramePointer(Magic.getFramePointer()));
-+		CompiledMethods.getCompiledMethod(disabledCMID).getMethod();
-+		//Leave this operation until !yieldpoinEnabled in yieldpoint().
-+//		if(!isOutOfBoundary(disabledCMID) && !ProfileQueue.isShortButFreqMethod(disabledCMID)
-+//				&& ProfileQueue.hotMethodsByExeTime[disabledCMID]) {
-+//
-+//		}
-+		RVMThread myThread = RVMThread.getCurrentThread();
-+		RVMMethod method = CompiledMethods.getCompiledMethod(disabledCMID).getMethod();
-+
-+		myThread.preDisableYieldpoints(disabledCMID);
-+		return method;
-+  }
-+
-+  /**
-+   * record method id and increase its yield point enable count by 1 after the stack is operated
-+   * @author kenan
-+   * @return Compiled method name before yield point is disabled
-+   */
-+  public static RVMMethod postYPEnabled() {
-+		//Kenan: record method id after the stack is operated by GC
-+		int disabledCMID = Magic.getCompiledMethodID(Magic.getCallerFramePointer(Magic.getFramePointer()));
-+		CompiledMethods.getCompiledMethod(disabledCMID).getMethod();
-+		//Leave this operation until !yieldpoinEnabled in yieldpoint().
-+//		if(!isOutOfBoundary(disabledCMID) && !ProfileQueue.isShortButFreqMethod(disabledCMID)
-+//				&& ProfileQueue.hotMethodsByExeTime[disabledCMID]) {
-+//
-+//		}
-+		RVMThread myThread = RVMThread.getCurrentThread();
-+		RVMMethod method = CompiledMethods.getCompiledMethod(disabledCMID).getMethod();
-+
-+		myThread.postEnableYieldpoints(disabledCMID);
-+		return method;
-+  }
-+
-+
-+  /**
-    * enable GC; entry point when recursion is not OK.
-    */
-   @Inline
-diff --git a/rvm/src/org/jikesrvm/adaptive/controller/AnalyticModel.java b/rvm/src/org/jikesrvm/adaptive/controller/AnalyticModel.java
-index cb335196d..bf7f16094 100644
---- a/rvm/src/org/jikesrvm/adaptive/controller/AnalyticModel.java
-+++ b/rvm/src/org/jikesrvm/adaptive/controller/AnalyticModel.java
-@@ -19,6 +19,7 @@ import org.jikesrvm.adaptive.recompilation.CompilerDNA;
- import org.jikesrvm.adaptive.util.AOSLogging;
- import org.jikesrvm.classloader.NormalMethod;
- import org.jikesrvm.compilers.common.CompiledMethod;
-+import org.jikesrvm.energy.ProfileQueue;
- 
- /**
-  * This class encapsulates the analytic model used by the controller
-@@ -75,6 +76,23 @@ abstract class AnalyticModel extends RecompilationStrategy {
-   }
- 
-   /**
-+   * Keep the priority queue for energy profiling using.
-+   * @author kenan
-+   * @param cmpMethod
-+   * @param hme
-+   */
-+  void considerHotMethodForEventCounter(CompiledMethod cmpMethod, HotMethodEvent hme, double futureTimeForMethod) {
-+	  if(futureTimeForMethod > Controller.options.HOT_METHOD_TIME_MIN && futureTimeForMethod < Controller.options.HOT_METHOD_TIME_MAX) {
-+		  ProfileQueue.insertToLongMethods(hme.getCMID());
-+	  }
-+//	  if(futureTimeForMethod >= 80) {
-+//		  ProfileQueue.insertToHotMethodsByFrq(hme.getCMID());
-+////		  ProfileQueue.hotMethodExeTime[hme.getCMID()] = futureTimeForMethod;
-+////		  VM.sysWriteln("hot method is: " + cmpMethod.getMethod());
-+//	  }
-+  }
-+
-+  /**
-    * This method is the main decision making loop for all
-    * recompilation strategies that use the analytic model.
-    * <p>
-@@ -112,6 +130,18 @@ abstract class AnalyticModel extends RecompilationStrategy {
-     // method at each greater compilation level.
-     double futureTimeForMethod = futureTimeForMethod(hme);
- 
-+
-+    //Kenan: After considerForRecompilation method, we do hot method
-+    //recognition for energy. Since recompilation operation would
-+    //transfer the current numSamples of the cmid to the new cmid of
-+    //another plan, which would keep the priority. So we can delay energy
-+    //profiling until next time running in the same method (with new cmid).
-+
-+    //Cannot separate this method from process() since it has dependencies
-+    //for each operation within considerHotMethod().
-+
-+//    considerHotMethodForEventCounter(cmpMethod, hme, futureTimeForMethod);
-+
-     // initialize bestAction as doing nothing, which means we'll
-     // spend just as much time in the method in the future as we have so far.
-     RecompilationChoice bestActionChoice = null;
-@@ -127,6 +157,7 @@ abstract class AnalyticModel extends RecompilationStrategy {
- 
-     // Consider all choices in the vector of possibilities
-     NormalMethod meth = (NormalMethod) hme.getMethod();
-+//    VM.sysWriteln("consider hot maethod name: " + meth.getName());
-     for (RecompilationChoice choice : recompilationChoices) {
-       // Get the cost and benefit of this choice
-       double cost = choice.getCost(meth);
-diff --git a/rvm/src/org/jikesrvm/adaptive/controller/ControllerThread.java b/rvm/src/org/jikesrvm/adaptive/controller/ControllerThread.java
-index 7b4e4f758..e0afff7bb 100644
---- a/rvm/src/org/jikesrvm/adaptive/controller/ControllerThread.java
-+++ b/rvm/src/org/jikesrvm/adaptive/controller/ControllerThread.java
-@@ -12,6 +12,7 @@
-  */
- package org.jikesrvm.adaptive.controller;
- 
-+import org.jikesrvm.adaptive.measurements.organizers.MethodEventCounterOrganizer;
- import java.util.Enumeration;
- import org.jikesrvm.VM;
- import org.jikesrvm.adaptive.OnStackReplacementEvent;
-@@ -152,6 +153,28 @@ public final class ControllerThread extends SystemThread {
- 
-     controllerInitDone();
- 
-+    //Kenan
-+    /**@author kenan
-+     * Initialize Scaler files.
-+     */
-+//    if (!isOpenScaleFile) {
-+//  		Scaler.initScaler();
-+//  		EnergyCheckUtils.initJrapl();
-+//  		Scaler.openDVFSFiles();
-+//  	    VM.sysWriteln("Stack is going to be initialized!");
-+//  	    ProfileStack.InitStack(EnergyCheckUtils.socketNum);
-+//  	    ProfileQueue.initShortButFreqMethods();
-+//  	    LogStack.InitStack(EnergyCheckUtils.socketNum);
-+//  		isOpenScaleFile = true;
-+//	  }
-+
-+    //Initialize profiling structure for energy/hardware counters
-+//    ProfileQueue.initHotMethodQueue();
-+//    ProfileQueue.initEventCounterQueue();
-+
-+//    if(Controller.options.ENABLE_COUNTER_PRINTER) {
-+//    	ProfileQueue.initCorrelationMatrix();
-+//    }
-     // Enter main controller loop.
-     // Pull an event to process off of
-     // Controller.controllerInputQueue and handle it.
-@@ -162,6 +185,8 @@ public final class ControllerThread extends SystemThread {
-       if (opts.EARLY_EXIT && opts.EARLY_EXIT_TIME < Controller.controllerClock) {
-         Controller.stop();
-       }
-+
-+    //Kenan: unthread-safe here?
-       Object event = Controller.controllerInputQueue.deleteMin();
-       ((ControllerInputEvent) event).process();
-     }
-@@ -263,6 +288,8 @@ public final class ControllerThread extends SystemThread {
- 
-       // Install organizer to drive method recompilation
-       Controller.organizers.add(new MethodSampleOrganizer(opts.DERIVED_FILTER_OPT_LEVEL));
-+      //Kenan: Install organizer to drive event counter profiling.
-+      Controller.organizers.add(new MethodEventCounterOrganizer());
-       // Additional set up for feedback directed inlining
-       if (opts.ADAPTIVE_INLINING) {
-         Organizer decayOrganizer = new DecayOrganizer(new YieldCounterListener(opts.DECAY_FREQUENCY));
-diff --git a/rvm/src/org/jikesrvm/adaptive/measurements/RuntimeMeasurements.java b/rvm/src/org/jikesrvm/adaptive/measurements/RuntimeMeasurements.java
-index 6548614c2..87c3ede15 100644
---- a/rvm/src/org/jikesrvm/adaptive/measurements/RuntimeMeasurements.java
-+++ b/rvm/src/org/jikesrvm/adaptive/measurements/RuntimeMeasurements.java
-@@ -14,9 +14,12 @@ package org.jikesrvm.adaptive.measurements;
- 
- import java.util.Vector;
- 
-+import org.jikesrvm.energy.ProfileQueue;
-+import org.jikesrvm.ia32.StackframeLayoutConstants;
- import org.jikesrvm.adaptive.controller.Controller;
- import org.jikesrvm.adaptive.measurements.listeners.ContextListener;
- import org.jikesrvm.adaptive.measurements.listeners.MethodListener;
-+import org.jikesrvm.adaptive.measurements.listeners.MethodEventCounterListener;
- import org.jikesrvm.adaptive.measurements.listeners.NullListener;
- import org.jikesrvm.adaptive.util.AOSLogging;
- import org.jikesrvm.architecture.StackFrameLayout;
-@@ -67,6 +70,38 @@ public abstract class RuntimeMeasurements {
-    */
-   private static NullListener[] timerNullListeners = new NullListener[0];
- 
-+  //Kenan
-+  private static MethodEventCounterListener[] eventCounterMethodListeners;
-+
-+
-+  public static void initEventCounterMethodListener() {
-+	  if(eventCounterMethodListeners == null)
-+		  eventCounterMethodListeners = new MethodEventCounterListener[0];
-+  }
-+  /**
-+   * Install a method energy listener on timer ticks = new MethodEnergyListener[0];
-+   * @author kenan
-+   * @param s
-+   */
-+  public static synchronized void installEventCounterMethodListener(MethodEventCounterListener s) {
-+//	  eventCounterMethodListeners = new MethodEnergyListener[0];
-+//	  if(eventCounterMethodListeners.length == 0) {
-+//	  VM.sysWriteln("-----------kenan: install energy method listerner set----------");
-+//	  }
-+	  int numListeners = eventCounterMethodListeners.length;
-+//	  VM.sysWriteln("timerNullListeners initialize size: " + timerNullListeners.length );
-+//	  VM.sysWriteln("eventCounterMethodListeners initialize size: " + numListeners );
-+	  MethodEventCounterListener[] tmp = new MethodEventCounterListener[numListeners + 1];
-+	    for (int i = 0; i < numListeners; i++) {
-+	        tmp[i] = eventCounterMethodListeners[i];
-+	      }
-+//	  System.arraycopy(eventCounterMethodListeners, 0, tmp, 0, numListeners);
-+	    tmp[numListeners] = s;
-+	  eventCounterMethodListeners = tmp;
-+
-+//	  VM.sysWriteln("after initialize size: " + eventCounterMethodListeners.length);
-+  }
-+
-   /**
-    * Install a method listener on timer ticks
-    * @param s method listener to be installed
-@@ -109,6 +144,70 @@ public abstract class RuntimeMeasurements {
-     timerNullListeners = tmp;
-   }
- 
-+
-+public static boolean isOutOfBoundary(int cmid) {
-+	  return ProfileQueue.longMethods.length <= cmid;
-+//	return true;
-+}
-+/**
-+ * Called from Thread.yieldpoint to do event counter profiling.
-+ * @author Kenan
-+ * @param whereFrom
-+ * @param yieldpointServiceMethodFP
-+ */
-+@Uninterruptible
-+public static void takeEventCounterSample(int whereFrom, Address yieldpointServiceMethodFP) {
-+//	VM.sysWriteln("Kenan: take event counter sample begins!");
-+	    Address ypTakenInFP = Magic.getCallerFramePointer(yieldpointServiceMethodFP); // method that took yieldpoint
-+	    // Get the cmid for the method in which the yieldpoint was taken.
-+	    int ypTakenInCMID = Magic.getCompiledMethodID(ypTakenInFP);
-+
-+	    if(isOutOfBoundary(ypTakenInCMID))
-+	    	return;
-+
-+	    //In the first stage of AOS run, all methods are cold.
-+	    //After that, If the current method is considered
-+	    //as hot method by its execution time in previous stage.
-+	    // Get the cmid for that method's caller.
-+		if (!ProfileQueue.isShortMethod(ypTakenInCMID) && ProfileQueue.longMethods[ypTakenInCMID]) {
-+//			VM.sysWriteln("Kenan: The method id is: " + ypTakenInCMID + " the future execution time is: " + ProfileQueue.hotMethodExeTime[ypTakenInCMID]);
-+			Address ypTakenInCallerFP = Magic
-+					.getCallerFramePointer(ypTakenInFP);
-+			int ypTakenInCallerCMID = Magic
-+					.getCompiledMethodID(ypTakenInCallerFP);
-+
-+			// Determine if ypTakenInCallerCMID corresponds to a real Java
-+			// stackframe.
-+			// If one of the following conditions is detected, set
-+			// ypTakenInCallerCMID to -1
-+			// Caller is out-of-line assembly (no RVMMethod object) or
-+			// top-of-stack psuedo-frame
-+			// Caller is a native method
-+			CompiledMethod ypTakenInCM = CompiledMethods
-+					.getCompiledMethod(ypTakenInCMID);
-+//			if(whereFrom == RVMThread.PROLOGUE)
-+//				VM.sysWriteln("taken event counter sample method prologue: " + ypTakenInCM.getMethod());
-+//			else if(whereFrom == RVMThread.EPILOGUE)
-+//				VM.sysWriteln("taken event counter sample method epilogue: " + ypTakenInCM.getMethod());
-+//			VM.sysWriteln("Kenan: The method id is: " + ypTakenInCMID +
-+//					" method name is: " + ypTakenInCM.getMethod() + " the future execution time is: " + ProfileQueue.hotMethodExeTime[ypTakenInCMID]);
-+			if (ypTakenInCallerCMID == StackframeLayoutConstants.INVISIBLE_METHOD_ID
-+					|| ypTakenInCM.getMethod().getDeclaringClass()
-+							.hasBridgeFromNativeAnnotation()) {
-+				ypTakenInCallerCMID = -1;
-+			} else {
-+				// Notify all registered listeners
-+				for (MethodEventCounterListener listener : eventCounterMethodListeners) {
-+					if (listener.isActive()) {
-+						listener.update(ypTakenInCMID, whereFrom, ypTakenInCM);
-+					}
-+				}
-+
-+			}
-+		} else {
-+//			VM.sysWriteln("current method is cold");
-+		}
-+}
-   /**
-    * Called from Thread.yieldpoint every time it is invoked due to
-    * a timer interrupt.
-diff --git a/rvm/src/org/jikesrvm/classloader/NormalMethod.java b/rvm/src/org/jikesrvm/classloader/NormalMethod.java
-index 1714231a2..f04912d64 100644
---- a/rvm/src/org/jikesrvm/classloader/NormalMethod.java
-+++ b/rvm/src/org/jikesrvm/classloader/NormalMethod.java
-@@ -40,6 +40,8 @@ public final class NormalMethod extends RVMMethod {
-    * This information is used to estimate how big a method will be when
-    * it is inlined.
-    */
-+	//Kenan: method ID for energy/event counter measurements
-+	public int methodID = -1;
-   public static final int SIMPLE_OPERATION_COST = 1;
-   public static final int LONG_OPERATION_COST = 2;
-   public static final int ARRAY_LOAD_COST = 2;
-diff --git a/rvm/src/org/jikesrvm/compilers/common/RuntimeCompiler.java b/rvm/src/org/jikesrvm/compilers/common/RuntimeCompiler.java
-index d97e5c1be..057914110 100644
---- a/rvm/src/org/jikesrvm/compilers/common/RuntimeCompiler.java
-+++ b/rvm/src/org/jikesrvm/compilers/common/RuntimeCompiler.java
-@@ -759,6 +759,7 @@ public class RuntimeCompiler implements Callbacks.ExitMonitor {
-                 cm = baselineCompile(method);
-                 ControllerMemory.incrementNumBase();
-               } else {
-+            	  VM.sysWriteln("Kenan: Do recompile!!");
-                 cm = plan.doRecompile();
-                 if (cm == null) {
-                   // opt compilation aborted for some reason.
-diff --git a/rvm/src/org/jikesrvm/runtime/BootRecord.java b/rvm/src/org/jikesrvm/runtime/BootRecord.java
-index 88996d9e0..aa4b5332b 100644
---- a/rvm/src/org/jikesrvm/runtime/BootRecord.java
-+++ b/rvm/src/org/jikesrvm/runtime/BootRecord.java
-@@ -406,4 +406,26 @@ public class BootRecord {
-   public Address sysPerfEventDisableIP;
-   public Address sysPerfEventReadIP;
- 
-+
-+    //RAPL methods
-+    public Address ProfileInitIP;
-+    public Address GetSocketNumIP;
-+    public Address SetPowerLimitIP;
-+    public Address GetPackagePowerSpecIP;
-+    public Address GetDramPowerSpecIP;
-+    public Address SetPackagePowerLimitIP;
-+    public Address SetPackageTimeWindowLimitIP;
-+    public Address SetDramTimeWindowLimitIP;
-+    public Address SetDramPowerLimitIP;
-+    public Address EnergyStatCheckIP;
-+    public Address ProfileDeallocIP;
-+    public Address SetGovernorIP;
-+    public Address GetGovernorIP;
-+    public Address getCpuNumIP;
-+    public Address getCurrentCpuIP;
-+    public Address ScaleIP;
-+    public Address FreqAvailableIP;
-+    public Address checkFrequencyIP;
-+    public Address openDVFSFilesIP;
-+    public Address closeDVFSFilesIP;
- }
-diff --git a/rvm/src/org/jikesrvm/runtime/Entrypoints.java b/rvm/src/org/jikesrvm/runtime/Entrypoints.java
-index 330420e86..b54a7afd3 100644
---- a/rvm/src/org/jikesrvm/runtime/Entrypoints.java
-+++ b/rvm/src/org/jikesrvm/runtime/Entrypoints.java
-@@ -30,6 +30,16 @@ public class Entrypoints {
-   //  2. the class containing the specified member didn't get compiled
-   //
- 
-+	//Kenan: Entrypoints for hot method measurement
-+	public static final NormalMethod startProfile =
-+			getMethod(org.jikesrvm.energy.Service.class, "startProfile", "(I)V");
-+
-+		public static final NormalMethod endProfile =
-+				getMethod(org.jikesrvm.energy.Service.class, "endProfile", "(I)V");
-+
-+//		public static final NormalMethod ioArgSampling =
-+//				getMethod(org.jikesrvm.energy.Service.class, "ioArgSampling", "(Ljava/lang/Object;)V");
-+
-   public static final NormalMethod bootMethod = EntrypointHelper.getMethod(org.jikesrvm.VM.class, "boot", "()V");
- 
-   public static final RVMMethod java_lang_reflect_Method_invokeMethod =
-diff --git a/rvm/src/org/jikesrvm/runtime/Reflection.java b/rvm/src/org/jikesrvm/runtime/Reflection.java
-index 62753410d..40a2d009e 100644
---- a/rvm/src/org/jikesrvm/runtime/Reflection.java
-+++ b/rvm/src/org/jikesrvm/runtime/Reflection.java
-@@ -199,7 +199,8 @@ public class Reflection {
-       targetMethod.compile();
-       cm = targetMethod.getCurrentCompiledMethod();
-     }
--
-+    //Kenan
-+//    VM.sysWriteln("Before the yield point is disabled by reflection, the method is: " + cm.getMethod());
-     RVMThread.getCurrentThread().disableYieldpoints();
- 
-     CodeArray code = cm.getEntryCodeArray();
-diff --git a/rvm/src/org/jikesrvm/runtime/SysCall.java b/rvm/src/org/jikesrvm/runtime/SysCall.java
-index d275602a4..6dde887c8 100644
---- a/rvm/src/org/jikesrvm/runtime/SysCall.java
-+++ b/rvm/src/org/jikesrvm/runtime/SysCall.java
-@@ -481,5 +481,48 @@ public abstract class SysCall {
- 
-   @SysCallTemplate
-   public abstract void sysStackAlignmentTest();
-+
-+	   @SysCallTemplate
-+	   public abstract int ProfileInit();
-+	   @SysCallTemplate
-+	   public abstract int GetSocketNum();
-+	   @SysCallTemplate
-+	   public abstract void SetPowerLimit (int enable);
-+	   @SysCallTemplate
-+	   public abstract double[] GetPackagePowerSpec();
-+	   @SysCallTemplate
-+	   public abstract double[] GetDramPowerSpec();
-+	   @SysCallTemplate
-+	   public abstract void SetPackagePowerLimit(int socketId, int level, double custm_power);
-+	   @SysCallTemplate
-+	   public abstract void SetPackageTimeWindowLimit(int socketId, int level, double custm_time_window);
-+	   @SysCallTemplate
-+	   public abstract void SetDramTimeWindowLimit(int socketId, int level, double custm_time_window);
-+	   @SysCallTemplate
-+	   public abstract void SetDramPowerLimit(int socketId, int level, double custm_power);
-+	   @SysCallTemplate
-+	   public abstract void EnergyStatCheck(byte[] ener_info);
-+	   @SysCallTemplate
-+	   public abstract void ProfileDealloc();
-+	   @SysCallTemplate
-+	   public abstract int SetGovernor(byte[] name);
-+	   @SysCallTemplate
-+	   public abstract int GetGovernor(byte[] name);
-+	   @SysCallTemplate
-+	   public abstract int getCpuNum();
-+	   @SysCallTemplate
-+	   public abstract int getCurrentCpu();
-+	   @SysCallTemplate
-+	   public abstract int Scale(int name);
-+	   @SysCallTemplate
-+	   public abstract void FreqAvailable(int[] freq);
-+	   @SysCallTemplate
-+	   public abstract void openDVFSFiles();
-+
-+	   @SysCallTemplate
-+	   public abstract void closeDVFSFiles();
-+	
-+
-+
- }
- 
-diff --git a/rvm/src/org/jikesrvm/scheduler/RVMThread.java b/rvm/src/org/jikesrvm/scheduler/RVMThread.java
-index a7d70fc28..05393d5d9 100644
---- a/rvm/src/org/jikesrvm/scheduler/RVMThread.java
-+++ b/rvm/src/org/jikesrvm/scheduler/RVMThread.java
-@@ -21,6 +21,10 @@ import static org.jikesrvm.objectmodel.ThinLockConstants.TL_THREAD_ID_SHIFT;
- 
- import java.security.AccessController;
- import java.security.PrivilegedAction;
-+import org.jikesrvm.adaptive.controller.Controller;
-+
-+
-+import org.jikesrvm.energy.RuntimeScaler;
- 
- import org.jikesrvm.VM;
- import org.jikesrvm.adaptive.OSRListener;
-@@ -147,6 +151,28 @@ import org.vmmagic.unboxed.Word;
- @Uninterruptible
- @NonMoving
- public final class RVMThread extends ThreadContext {
-+
-+
-+  //Kenan
-+  public final static int entrySize = 256;
-+  public int methodYPDisabledCount = 0;
-+  //Index for YPDisabledMethodID
-+  public int YPNextIndex = 0;
-+	/*
-+	 * Energy/hardware counter measurement when yieldpoint of methods are disabled when yieldpoint() gets invoked.
-+	 * Record yieldpoint of methods that are disabled by compiled method stack based operations for each thread.
-+	 * Eg. disableGC() and etc.
-+	 */
-+  /**This array maps cmid to index*/
-+  public int[] YPDisabledMethodIndex = new int[entrySize + (entrySize >>> 2)];
-+  /**Index for each method*/
-+  public int[] YPDisabledMethodID = new int[entrySize];
-+  /**If it's 1, the yieldpoint is enabled, < 1 it's not. Just like yieldpointsEnabledCount*/
-+  public int[] YPDisabledMethods = new int[entrySize];
-+  /**Counter for yield point disabled by GC only*/
-+  public int YPDisabledCountByGC = 0;
-+
-+
-   /*
-    * debug and statistics
-    */
-@@ -1637,6 +1663,11 @@ public final class RVMThread extends ThreadContext {
-     * @param priority The threads execution priority.
-     */
-    public RVMThread(byte[] stack, Thread thread, String name, boolean daemon, SystemThread systemThread, int priority) {
-+	//Kenan
-+//	YPDisabledMethodIndex = new int[entrySize + (entrySize >>> 2)];
-+//	YPDisabledMethodID = new int[entrySize];
-+//	YPDisabledMethods = new int[entrySize];
-+
-     this.stack = stack;
- 
-     this.daemon = daemon;
-@@ -2598,6 +2629,70 @@ public final class RVMThread extends ThreadContext {
-     --yieldpointsEnabledCount;
-   }
- 
-+  /*
-+   * Kenan: Methods handling energy/hardware counter profiling when yield point disabled
-+   */
-+
-+  /**Increase yield point enabled count by 1 for each method before enableYieldpoints()*/
-+  public void postEnableYieldpoints(int cmid) {
-+	  int index = 0;
-+	  if(!isOutBoundary(YPDisabledMethodIndex, cmid)) {
-+		  index = YPDisabledMethodIndex[cmid];
-+		  ++YPDisabledMethods[index];
-+		  return;
-+	  }
-+	  growSize(YPDisabledMethodIndex, cmid);
-+	  YPDisabledMethodIndex[cmid] = YPNextIndex;
-+	  growSize(YPDisabledMethodID, YPNextIndex);
-+	  YPDisabledMethodID[YPNextIndex] = cmid;
-+	  growSize(YPDisabledMethods, YPNextIndex);
-+	  ++YPDisabledMethods[index];
-+	  YPNextIndex++;
-+  }
-+
-+  /**Decrease yield point enabled count by 1 for each method before disableYieldpoints()*/
-+  public void preDisableYieldpoints(int cmid) {
-+	  int index = 0;
-+	  if(!isOutBoundary(YPDisabledMethodIndex, cmid)) {
-+		  index = YPDisabledMethodIndex[cmid];
-+		  --YPDisabledMethods[index];
-+		  return;
-+	  }
-+	  growSize(YPDisabledMethodIndex, cmid);
-+	  YPDisabledMethodIndex[cmid] = YPNextIndex;
-+	  growSize(YPDisabledMethodID, YPNextIndex);
-+	  YPDisabledMethodID[YPNextIndex] = cmid;
-+	  growSize(YPDisabledMethods, YPNextIndex);
-+	  --YPDisabledMethods[index];
-+	  YPNextIndex++;
-+  }
-+
-+  /**
-+   * @param methodList
-+   * @param index
-+   * @return true if the index is out of array boundary
-+   */
-+  public boolean isOutBoundary(int[] methodList, int index) {
-+	  return methodList.length <= index;
-+  }
-+
-+  /**
-+   * @param methodList array to be increased
-+   * @param index array index
-+   */
-+	public void growSize(int[] methodList, int index) {
-+		//Index of method ID may be way larger than the current array size.
-+		while(isOutBoundary(methodList, index)) {
-+			int[] newQueue = new int[Math.max(index + 1, (int) (methodList.length * 1.25))];
-+			System.arraycopy(methodList, 0, newQueue, 0, methodList.length);
-+			methodList = newQueue;
-+		}
-+	}
-+
-+	/*
-+	 * Kenan: End
-+	 */
-+
-   /**
-    * Fail if yieldpoints are disabled on this thread
-    */
-@@ -4209,6 +4304,31 @@ public final class RVMThread extends ThreadContext {
-     Throwable throwThis = null;
-     t.monitor().lockNoHandshake();
- 
-+    //Kenan: Check if the current method of energy consumption needs to measured.
-+    t.checkBlock();
-+    /*
-+     * kenan: After considering hot method by execution time, further filter hot methods for
-+     * dynamic scaling by considering hardware events. Eg. cache miss rate and TLB miss.
-+     */
-+//    for(int i = 0; i < t.YPDisabledMethods.length; i++) {
-+//		int id = t.YPDisabledMethodID[i];
-+//		VM.sysWriteln("YPDisabledMethodID: " + id);
-+//    }
-+
-+//	if (ypTakenInCallerCMID != StackframeLayoutConstants.INVISIBLE_METHOD_ID
-+//			&& !ypTakenInCM.getMethod().getDeclaringClass()
-+//					.hasBridgeFromNativeAnnotation()) {
-+//		if(whereFrom == RVMThread.PROLOGUE)
-+//			VM.sysWriteln("taken event counter sample method prologue: " + ypTakenInCM.getMethod());
-+//		else if(whereFrom == RVMThread.EPILOGUE)
-+//			VM.sysWriteln("taken event counter sample method epilogue: " + ypTakenInCM.getMethod());
-+//	}
-+//      RuntimeMeasurements.takeEventCounterSample(whereFrom, yieldpointServiceMethodFP);
-+      //If dynamic scaling is enabled
-+      if(Controller.options.ENABLE_SCALING_BY_COUNTERS) {
-+    	  RuntimeScaler.dynamicScale(whereFrom, yieldpointServiceMethodFP);
-+      }
-+
-     int takeYieldpointVal = t.takeYieldpoint;
-     if (takeYieldpointVal != 0) {
-       t.takeYieldpoint = 0;
-diff --git a/rvm/src/org/jikesrvm/scheduler/TimerThread.java b/rvm/src/org/jikesrvm/scheduler/TimerThread.java
-index 5c29b2208..a5078cfb6 100644
---- a/rvm/src/org/jikesrvm/scheduler/TimerThread.java
-+++ b/rvm/src/org/jikesrvm/scheduler/TimerThread.java
-@@ -52,6 +52,7 @@ public class TimerThread extends SystemThread {
-           // grab the lock to prevent threads from getting GC'd while we are
-           // iterating (since this thread doesn't stop for GC)
-           RVMThread.acctLock.lockNoHandshake();
-+
-           RVMThread.timerTicks++;
-           for (int i = 0; i < RVMThread.numThreads; ++i) {
-             RVMThread candidate = RVMThread.threads[i];
-diff --git a/tools/bootloader/sys.h b/tools/bootloader/sys.h
-index 1a99b5769..e7b908750 100644
---- a/tools/bootloader/sys.h
-+++ b/tools/bootloader/sys.h
-@@ -126,6 +126,28 @@ extern void* checkMalloc(int length);
- extern void* checkCalloc(int numElements, int sizeOfOneElement);
- extern void checkFree(void* mem);
- 
-+/**  Adding Kenan Related Files **/
-+EXTERNAL int k_poc_sys_call();
-+EXTERNAL void closeDVFSFiles();
-+EXTERNAL void openDVFSFiles();
-+EXTERNAL int checkFrequency();
-+EXTERNAL void FreqAvailable(int *);
-+EXTERNAL int Scale(int);
-+EXTERNAL int getCurrentCpu();
-+EXTERNAL int getCpuNum();
-+EXTERNAL int SetGovernor(const char*);
-+EXTERNAL int GetGovernor(char*);
-+EXTERNAL void ProfileDealloc();
-+EXTERNAL void EnergyStatCheck(char *);
-+EXTERNAL void SetDramPowerLimit(int , int , double);
-+EXTERNAL void SetPackageTimeWindowLimit(int , int , double);
-+EXTERNAL void SetPackagePowerLimit(int , int , double );
-+EXTERNAL double * GetDramPowerSpec();
-+EXTERNAL double * GetPackagePowerSpec();
-+EXTERNAL void SetPowerLimit (int);
-+EXTERNAL int GetSocketNum();
-+EXTERNAL int ProfileInit();
-+
- // sysAlignmentCheck
- extern volatile int numEnableAlignCheckingCalls;
- EXTERNAL void sysEnableAlignmentChecking();
-@@ -306,6 +328,8 @@ EXTERNAL void sysThreadYield();
- EXTERNAL Word sysGetThreadPriorityHandle();
- EXTERNAL int sysGetThreadPriority(Word thread, Word handle);
- EXTERNAL int sysSetThreadPriority(Word thread, Word handle, int priority);
-+EXTERNAL void SetDramTimeWindowLimit(int, int, double);
-+
- // sysThread - architecture specific
- // parameters are architecture specific too.
- EXTERNAL void bootThread(void *, void *, void *, void *);
diff --git a/rvm/src/org/jikesrvm/compilers/opt/hir2lir/ExpandRuntimeServices.java b/rvm/src/org/jikesrvm/compilers/opt/hir2lir/ExpandRuntimeServices.java
index e470d8052..e614f91a0 100644
--- a/rvm/src/org/jikesrvm/compilers/opt/hir2lir/ExpandRuntimeServices.java
+++ b/rvm/src/org/jikesrvm/compilers/opt/hir2lir/ExpandRuntimeServices.java
@@ -145,7 +145,7 @@ public final class ExpandRuntimeServices extends CompilerPhase {
    */
   @Override
   public void perform(IR ir) {
-     ir.getGc().resync(); // resync generation context -- yuck...
+        ir.getGc().resync(); // resync generation context -- yuck...
       	if (Controller.options.ENABLE_COUNTER_PROFILING || Controller.options.ENABLE_ENERGY_PROFILING) {
 	                      org.jikesrvm.energy.Instrumentation instru = new org.jikesrvm.energy.Instrumentation(ir);
 			              //      instru.instrumentIO();
diff --git a/rvm/src/org/jikesrvm/energy/EnergyCheckUtils.java b/rvm/src/org/jikesrvm/energy/EnergyCheckUtils.java
index 2cd3063cf..e2cc548a9 100644
--- a/rvm/src/org/jikesrvm/energy/EnergyCheckUtils.java
+++ b/rvm/src/org/jikesrvm/energy/EnergyCheckUtils.java
@@ -56,10 +56,13 @@ public class EnergyCheckUtils {
 		SysCall.sysCall.EnergyStatCheck(energyBuf);
 		
 		String energyInfo = StringUtilities.asciiBytesToString(energyBuf).trim();
+		
 		/*One Socket*/
 		if(socketNum == 1) {
+			//VM.sysWriteln("Added by mahmou1 to trace Parse Excetion  \n\n");
 			double[] stats = new double[3];
 			String[] energy = energyInfo.split("#");
+			//VM.sysWriteln("\n\n\n\n energyInfo:(" + energyInfo + ")\n\n\n\n");
 			stats[0] = Double.parseDouble(energy[0]);
 			stats[1] = Double.parseDouble(energy[1]);
 			stats[2] = Double.parseDouble(energy[2]);
diff --git a/rvm/src/org/jikesrvm/energy/a b/rvm/src/org/jikesrvm/energy/a
deleted file mode 100644
index e69de29bb..000000000
diff --git a/rvm/src/org/jikesrvm/energy/b b/rvm/src/org/jikesrvm/energy/b
deleted file mode 100644
index df3b08a2a..000000000
--- a/rvm/src/org/jikesrvm/energy/b
+++ /dev/null
@@ -1 +0,0 @@
-Oh my Goooood
diff --git a/tools/bootloader/energy.c b/tools/bootloader/energy.c
index b06662bc1..3d3222cc6 100644
--- a/tools/bootloader/energy.c
+++ b/tools/bootloader/energy.c
@@ -11,7 +11,9 @@
 #include "energy.h"
 
 uint32_t eax, ebx, ecx, edx;
-uint32_t cpu_model;
+
+//Modified by kmahmou1 to assign 45 to the CPU Model
+uint32_t cpu_model = 45;
 
 //int read_time = 0;
 //int core = 0;
diff --git a/tools/bootloader/kenan.c b/tools/bootloader/kenan.c
index f047d9019..e58d85c4a 100644
--- a/tools/bootloader/kenan.c
+++ b/tools/bootloader/kenan.c
@@ -314,7 +314,13 @@ EXTERNAL EnergyStatCheck(char *ener_info) {
 	int i;
 	int offset = 0;
 	int end_str_index = 0;
-
+	
+	//printf("Added by kmahmou1 to trace EnergyStatCheck \n");
+	//printf("num_pkg %i \n", num_pkg);
+	//printf("cpu_model: %i : \n", cpu_model);
+	//printf("SANDYBRIDGE_EP %i \n", SANDYBRIDGE_EP);
+	//printf("SANDYBRIDGE %i \n", SANDYBRIDGE);
+	//printf("IVYBRIDGE %i \n", IVYBRIDGE);
 
 	for(i = 0; i < num_pkg; i++) {
 		char gpu_buffer[60];
@@ -331,10 +337,11 @@ EXTERNAL EnergyStatCheck(char *ener_info) {
 
 		sprintf(package_buffer, "%f", package[i]);
 		sprintf(cpu_buffer, "%f", pp0[i]);
-
+	
 		//allocate space for string
 		switch(cpu_model) {
 			case SANDYBRIDGE_EP:
+				//printf("Addy kmahmou1 to trace energy status SANDYBRIDGE_EP \n ");
 				result = read_msr(fd[i],MSR_DRAM_ENERGY_STATUS);
 				dram[i] =(double)result*rapl_unit.energy;
 
@@ -367,7 +374,7 @@ EXTERNAL EnergyStatCheck(char *ener_info) {
 				break;
 			case SANDYBRIDGE:
 			case IVYBRIDGE:
-
+				//printf("Addy kmahmou1 to trace energy status SANDYBRIDGE/IVYBR \n ");
 				result = read_msr(fd[i],MSR_PP1_ENERGY_STATUS);
 				pp1[i] = (double) result *rapl_unit.energy;
 
